1. Current architecture (today)
There is one FastAPI service running locally as the main brain:

Directory: C:\Users\ohado\Documents\3.6.Nife\RILIE (3,6,9)

Module: api.py

Port: 8000

Purpose: expose RILIE, wire in Brave Search, and host the PREâ€‘RESPONSE endpoint.
â€‹

RILIE itself is implemented as a 5â€‘act stack:

rilie_triangle.py: Bouncer / Triangle safety + nonsense gate.
â€‹

rilie_ddd.py: DDD / Hostess, sets disclosure level, taste, courtesy exits.
â€‹

rilie_core.py: Kitchen pass pipeline, multiâ€‘pass interpretation and selfâ€‘scoring.
â€‹

rilie.py: â€œThe Restaurantâ€ that composes Triangle + DDD + Kitchen and handles conversation state.
â€‹

guvna.py: Act 5 Governor sitting above RILIE, adding tone, web baselines, and final envelope.
â€‹

Brave Search is wired in as the live web baseline:

Env: BRAVEAPIKEY must be set in your environment.

URL: https://api.search.brave.com/res/v1/web/search.

bravewebsearch(query, numresults) returns a list of {title, link, snippet} dicts.

bravesearchsync wraps that for synchronous use as RILIEâ€™s searchfn.
â€‹

The Governor is currently wired like this in api.py:

Roux seeds are loaded from ROUX.json + RInitials/*.txt via loadroux().
â€‹

These seeds and the Brave search function are passed into Guvna(rouxseeds=rouxseeds, searchfn=wiredsearchfn).

There is no running BANKS microservice in this repo right now:

The older ARIES baton described a separate banks_service/main.py with SQLModel Query and Snippet tables.
â€‹

In the current code drop, there is only BANKSURL = os.getenv("BANKSURL", "http://127.0.0.1:8001") as a placeholder, and /pre-response doesnâ€™t call any BANKS backend yet.
â€‹

2. RILIE brain + Governor behavior
RILIE (Acts 1â€“4):

RILIE.process(stimulus, maxpass, searchfn) does Triangle safety check, DDD disclosure, Kitchen multiâ€‘pass cooking, optional live Roux (Brave) search for cultural â€œroux,â€ and courtesy exit if she truly canâ€™t answer.
â€‹

Conversation state (disclosure level, history) lives inside ConversationState and persists per RILIE instance.
â€‹

Governor (Act 5) highâ€‘level flow:

Guess a tone from the raw stimulus (amusing, insightful, nourishing, compassionate, strategic) using simple keyword heuristics.
â€‹

If the topic contains serious keywords (race, genocide, diaspora, abuse, Palestine, etc.), prevent â€œamusingâ€ from being the governing tone; fall back to compassionate or insightful.
â€‹

Fetch a web baseline using Brave: pick the top result, combine title + snippet into a single text field, and keep link.
â€‹

Build an augmented stimulus: prepend Baseline from web (may be wrong, used only as context): <baseline> then Original question: <stimulus>, and send that into RILIE.process.

Choosing what to serve:

Read back result, status, and quality_score from RILIEâ€™s envelope.

If there is a baseline text and RILIE is clearly lowâ€‘confidence (status in {"MISE_EN_PLACE", "GUESS"} or quality < 0.25), the Governor is allowed to serve the baseline as the main body, with RILIEâ€™s attempt still present in the JSON for transparency.
â€‹

Otherwise, RILIEâ€™s cooked answer is the primary text, with the baseline kept as context.
â€‹

Tone header + metadata:

Whatever main text is chosen gets prefixed with a single tone header line: "Insight focus ğŸ’¡", "Care first â¤ï¸ğŸ©¹", etc., followed by a blank line, then the answer.
â€‹

The JSON envelope also exposes: tone, tone_emoji, baseline ({title, snippet, link, text}), baseline_used, and baseline_used_as_result.
â€‹

The main entrypoint /v1/rilie in api.py just:

Strips the incoming stimulus.

Returns an EMPTY status if itâ€™s blank.

Otherwise calls guvna.process(stimulus, maxpass=req.maxpass) and returns the full envelope directly to the client.
â€‹

3. PREâ€‘RESPONSE and BANKS (current vs planned)
Current PREâ€‘RESPONSE skeleton (/pre-response):

Request model: {question: str, shallow: bool = True, numresults: int = 9}.

If question is empty after strip, returns {status: "EMPTY", harvested: 0}.

Otherwise calls bravewebsearch(q, numresults), counts len(results) as harvested, and returns {question, shallow, harvested, status: "OK"}.

Importantly: no BANKS writes yet and no snippets returned; this is just a counter/demo.

Previous BANKS design (for context, not currently in repo):

Separate service banks_service/main.py on port 8001, with Postgres + SQLModel Query and Snippet tables.
â€‹

Endpoints to store a Query, bulk store its Snippets (with city/channel/url/title/snippet/rank), and search snippets via GET /search?q=....
â€‹

Planned BANKS v2 (simpler, localâ€‘first):

Instead of a separate FastAPI + SQLModel service, use a thin Postgres helper module banks.py sitting next to api.py. (This is the design we discussed; code is not yet in this repo.)

Target schema: a single banks_search_results table with columns roughly:
query_text, lens_city, lens_channel, provider, result_rank, title, snippet, url, fetched_at, status_code, raw_json.

Core helpers:

store_search_results(query_text, lens_city, lens_channel, provider, results) for bulk inserts per (city, channel).

search_banks_by_keywords(query_text, lens_city?, lens_channel?, limit) using Postgres fullâ€‘text search.

fanout_pre_response_queries(question, searchfn, cities, channels, per_query_results) to implement the PREâ€‘RESPONSE grid.

Planned PREâ€‘RESPONSE v2 behavior (once BANKS v2 exists):

For each incoming question, fan out across Rouxâ€‘style cities (Brooklyn, New Orleans, Nice, France, etc.) and channels (mind, body, soul, food, music, funny, film), building compound queries like "question + Brooklyn + music".
â€‹

Call Brave once per (city, channel) lens, store results in banks_search_results via store_search_results.

Return to the client:

question,

harvested = total stored rows,

maybe a small preview (top titles/snippets per lens) and a way to refer back to these rows later.

Planned RILIE â†” BANKS integration:

Add a small adapter that, given a new stimulus, can:

Query BANKS by keywords + city/channel preferences.

Use those snippets as extra context â€œrouxâ€ for the Kitchen passes, similar to how live Brave results are used now but without an external HTTP call every time.

4. How to run the current stack locally
Environment and Roux:

.env in project root is loaded by loadenvfile(BASEDIR / ".env"); OS environment overrides it.
â€‹

Roux seeds are read from ROUX.json plus text files in RInitials/ and passed into RILIE via Guvna.

Start the RILIE API service (current reality):

Ensure BRAVEAPIKEY is set.
â€‹

From RILIE (3,6,9) directory:

python -m uvicorn api:app --reload --host 127.0.0.1 --port 8000

Docs: http://127.0.0.1:8000/docs.

Sanity checks today:

GET /health on port 8000 should report status: "OK", architecture: "5-act-guvna", and indicate whether Brave/Vision are configured.
â€‹

POST /v1/googlesearch (legacy name, Brave backend) returns Brave results for a test query.
â€‹

POST /pre-response with a nonâ€‘empty question returns status: "OK" and harvested: <numresults> as a quick check that Brave is reachable.

What is not yet runnable from this repo:

Any BANKS service at :8001; the current code only keeps a BANKSURL default and a PREâ€‘RESPONSE skeleton that doesnâ€™t call it.
â€‹

Any Postgres migrations or banks_search_results table; these are still in the design phase, not implemented here.

5. Future phases and how we intend to implement
Phase 1 â€“ Tone and honesty stabilization (now)

Run only the local RILIE API with Brave wired in and no BANKS.

Hammer /v1/rilie with:

light prompts (music, jokes, playful questions),

heavy prompts (Fear of a Black Planet, 911 Is a Joke, race, trauma, Palestine, diaspora),

edge probes (nonsense, hostile prompts) to validate Triangle and courtesyâ€‘exit behavior.

Tune:

Guvna tone heuristics (keywords â†’ tone mapping).
â€‹

Thresholds for when baseline is allowed to override RILIEâ€™s answer (status + quality_score).

Phase 2 â€“ Local BANKS v2 (single Postgres + banks.py)

Stand up a local Postgres instance (could reuse the DSN from the old baton or a simpler oneâ€”exact credentials can be changed).
â€‹

Create banks_search_results table via a simple SQL migration or manual DDL.

Add banks.py in the same folder as api.py with:

get_db_conn() reading DATABASE_URL.

store_search_results() to bulk insert Brave results per lens.

search_banks_by_keywords() using to_tsvector / plainto_tsquery or even ILIKE to start.

fanout_pre_response_queries() implementing the multiâ€‘city, multiâ€‘channel PREâ€‘RESPONSE described in PRE-RESPONSE.txt.
â€‹

Replace the current /pre-response body in api.py with:

If shallow: just do current behavior (single Brave call, count).

If not shallow: call fanout_pre_response_queries(question, bravesearchsync) and return harvested = inserted_rows.

Phase 3 â€“ RILIE using BANKS as a local memory roux

Inside rilie_core or a thin adapter, add a step that:

For a given stimulus, queries BANKS for relevant snippets by keyword and maybe preferred city/channel.
â€‹

Feeds those snippets into the Kitchen as extra context, similar to live Brave but with zero external latency and more control.

Adjust courtesyâ€‘exit: if she canâ€™t answer, but BANKS has rich snippets, let her gracefully lean on that stored context.

Phase 4 â€“ Web client + deployment

Make the local HTML client (rilie-client.html) or a small React frontâ€‘end talk to /v1/rilie and /pre-response.
â€‹

Once local behavior feels right, deploy the same stack behind api.rilie.net (or equivalent) with:

TLS, CORS, simple auth if needed.

A managed Postgres instance for BANKS.

Use the same banks.py + Guvna code; only config (DATABASE_URL, BRAVEAPIKEY) changes.
â€‹

Phase 5 â€“ Integration into the Saucâ€‘e ecosystem

Expose this RILIE+Guvna+BANKS brain as the shared narrative / reasoning backend for Cheddar, Catsup, Relish, and friends, each with its own Roux profile and frontâ€‘end behavior.

Use BANKS not just for web snippets but also for firstâ€‘party user transcripts (with appropriate partitioning) so that Saucâ€‘e apps get a unified but privacyâ€‘respecting memory layer.