import os
import json
import time
import uuid
import base64
from pathlib import Path
from typing import Dict, Any, List, Optional, Callable

import urllib.parse
import urllib.request

import httpx  # Brave HTTP client

from fastapi import FastAPI, HTTPException, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from pydantic import BaseModel

from guvna import Guvna  # wired below with Roux + search_fn

# ---------------------------------------------------------------------------
# Base dir and .env loader (no external deps)
# ---------------------------------------------------------------------------

BASE_DIR = Path(__file__).resolve().parent


def load_env_file(path: Path) -> None:
    """
    Minimal .env loader: KEY=VALUE per line, # comments allowed.
    Values in OS env win; .env only fills missing ones.
    """
    if not path.exists():
        return
    for line in path.read_text(encoding="utf-8").splitlines():
        line = line.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        key, value = line.split("=", 1)
        key = key.strip()
        value = value.strip().strip("'").strip('"')
        os.environ.setdefault(key, value)


load_env_file(BASE_DIR / ".env")

# ---------------------------------------------------------------------------
# Paths and Roux loading (RILIE's 9-track soul)
# ---------------------------------------------------------------------------

ROUX_PATH = BASE_DIR / "ROUX.json"
RINITIALS_DIR = BASE_DIR / "RInitials"
GENERATED_DIR = BASE_DIR / "generated"


def load_roux() -> Dict[str, Dict[str, Any]]:
    """
    Load RILIE's 9-track roux from ROUX.json and the RInitials/*.txt files.
    The raw texts never leave this process; they are just used as invisible seeds.
    """
    if not ROUX_PATH.exists():
        return {}

    with ROUX_PATH.open("r", encoding="utf-8") as f:
        config = json.load(f)

    seeds: Dict[str, Dict[str, Any]] = {}
    for key, meta in config.items():
        file_name = meta.get("file")
        weight = meta.get("weight", 1.0)
        role = meta.get("role", "")
        text = ""
        if file_name:
            path = RINITIALS_DIR / file_name
            if path.exists():
                try:
                    text = path.read_text(encoding="utf-8")
                except Exception:
                    text = ""
        seeds[key] = {
            "text": text,
            "weight": float(weight),
            "role": role,
        }

    return seeds


GENERATED_DIR.mkdir(exist_ok=True)

# ---------------------------------------------------------------------------
# Brave Search configuration (replaces Google Custom Search)
# ---------------------------------------------------------------------------

BRAVE_API_KEY = os.getenv("BRAVE_API_KEY")
BRAVE_SEARCH_URL = "https://api.search.brave.com/res/v1/web/search"

# RILIE's SearchFn: query -> list of {title, link, snippet}
SearchFn = Callable[[str], List[Dict[str, str]]]


async def brave_web_search(
    query: str,
    num_results: int = 5,
) -> List[Dict[str, str]]:
    """
    Call Brave Search API and return a small, clean list of results
    with keys: title, link, snippet.
    """
    if not BRAVE_API_KEY:
        raise RuntimeError(
            "Brave Search API not configured (BRAVE_API_KEY)."
        )

    headers = {
        "Accept": "application/json",
        "X-Subscription-Token": BRAVE_API_KEY,
    }
    params = {
        "q": query,
        "count": max(1, min(num_results, 10)),
    }

    async with httpx.AsyncClient(timeout=10) as client:
        resp = await client.get(BRAVE_SEARCH_URL, headers=headers, params=params)
        resp.raise_for_status()
        data = resp.json()

    items: List[Dict[str, str]] = []
    for item in data.get("web", {}).get("results", []):
        items.append(
            {
                "title": item.get("title", ""),
                "link": item.get("url", ""),
                "snippet": item.get("description", ""),
            }
        )
    return items


def brave_search_sync(query: str, num_results: int = 5) -> List[Dict[str, str]]:
    """
    Synchronous wrapper so we can pass Brave into RILIE's SearchFn slot.
    """
    import asyncio

    return asyncio.run(brave_web_search(query, num_results))


HAS_BRAVE_SEARCH = bool(BRAVE_API_KEY)

# ---------------------------------------------------------------------------
# Google Vision OCR configuration (kept as-is for now)
# ---------------------------------------------------------------------------

GOOGLE_VISION_API_KEY = os.getenv("GOOGLE_VISION_API_KEY")
VISION_URL = "https://vision.googleapis.com/v1/images:annotate"


def google_ocr(image_bytes: bytes) -> str:
    """
    Call Google Cloud Vision OCR (TEXT_DETECTION) on raw image bytes and
    return the extracted text (fullTextAnnotation.text if available).
    """
    if not GOOGLE_VISION_API_KEY:
        raise RuntimeError(
            "Google Vision OCR not configured (GOOGLE_VISION_API_KEY)."
        )

    content_b64 = base64.b64encode(image_bytes).decode("utf-8")
    payload = {
        "requests": [
            {
                "image": {"content": content_b64},
                "features": [{"type": "TEXT_DETECTION"}],
            }
        ]
    }

    url = VISION_URL + "?key=" + urllib.parse.quote(GOOGLE_VISION_API_KEY)
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        url,
        data=data,
        headers={"Content-Type": "application/json"},
        method="POST",
    )

    with urllib.request.urlopen(req, timeout=15) as resp:
        resp_data = json.loads(resp.read().decode("utf-8"))

    responses = resp_data.get("responses", [])
    if not responses:
        return ""

    res0 = responses[0]
    full = res0.get("fullTextAnnotation", {})
    text = full.get("text")
    if text:
        return text

    ann = res0.get("textAnnotations", [])
    if not ann:
        return ""

    parts = [a.get("description", "") for a in ann]
    return "\n".join(parts)


HAS_GOOGLE_VISION = bool(GOOGLE_VISION_API_KEY)

# ---------------------------------------------------------------------------
# BANKS configuration (PRE-RESPONSE target)
# ---------------------------------------------------------------------------

BANKS_URL = os.getenv("BANKS_URL", "http://127.0.0.1:8001")

# ---------------------------------------------------------------------------
# FastAPI app + The Governor (Act 5)
# ---------------------------------------------------------------------------

app = FastAPI(title="RILIE API", version="0.6.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# Load Roux once at startup and wire it + search_fn into the Governor.
roux_seeds: Dict[str, Dict[str, Any]] = load_roux()

# Wire Brave into RILIE instead of Google
wired_search_fn: Optional[SearchFn] = brave_search_sync if HAS_BRAVE_SEARCH else None

guvna = Guvna(roux_seeds=roux_seeds, search_fn=wired_search_fn)

# ---------------------------------------------------------------------------
# Pydantic models
# ---------------------------------------------------------------------------


class RilieRequest(BaseModel):
    stimulus: str
    max_pass: int = 3


class SearchRequest(BaseModel):
    query: str
    num_results: int = 5


class GenerateFileRequest(BaseModel):
    stimulus: str
    ext: str  # md, js, py, json, txt, docx, pdf


class HealthResponse(BaseModel):
    status: str
    has_brave_search: bool
    has_google_vision: bool
    roux_tracks: int
    architecture: str


# PRE-RESPONSE models
class PreResponseRequest(BaseModel):
    question: str
    shallow: bool = True
    numresults: int = 9


class PreResponseResponse(BaseModel):
    question: str
    shallow: bool
    harvested: int
    status: str


# ---------------------------------------------------------------------------
# Helpers for generated files
# ---------------------------------------------------------------------------

ALLOWED_EXTENSIONS = {"md", "js", "py", "json", "txt", "docx", "pdf"}


def sanitize_ext(ext: str) -> str:
    ext = ext.lower().lstrip(".")
    if ext not in ALLOWED_EXTENSIONS:
        return "txt"
    return ext


def save_generated_file(ext: str, content: str) -> str:
    """Save content into generated/ and return the filename."""
    ext = sanitize_ext(ext)
    ts = int(time.time())
    token = uuid.uuid4().hex[:8]
    filename = f"rilie_{ts}_{token}.{ext}"
    path = GENERATED_DIR / filename
    path.write_text(content, encoding="utf-8")
    return filename


# ---------------------------------------------------------------------------
# Routes
# ---------------------------------------------------------------------------


@app.get("/health", response_model=HealthResponse)
def health() -> HealthResponse:
    """
    Simple health check: confirms API is alive, roux is loaded,
    and whether Brave Search / Vision are configured.
    """
    return HealthResponse(
        status="OK",
        has_brave_search=HAS_BRAVE_SEARCH,
        has_google_vision=HAS_GOOGLE_VISION,
        roux_tracks=len(roux_seeds),
        architecture="5-act-guvna",
    )


@app.post("/v1/rilie")
def run_rilie(req: RilieRequest) -> Dict[str, Any]:
    """
    Main RILIE endpoint — routes through the Guvna (Act 5).
    The Governor delegates to RILIE (Act 4), which orchestrates Acts 1–3.
    """
    stimulus = req.stimulus.strip()
    if not stimulus:
        return {
            "stimulus": "",
            "result": "Please enter a driving question for RILIE.",
            "quality_score": 0.0,
            "priorities_met": 0,
            "anti_beige_score": 0.0,
            "status": "EMPTY",
            "depth": 0,
            "pass": 0,
        }

    result = guvna.process(stimulus, maxpass=req.max_pass)
    return result


@app.post("/v1/google_search")
async def google_search_endpoint(req: SearchRequest) -> Dict[str, Any]:
    """
    Thin wrapper around Brave Search API (legacy name).
    RILIE or the frontend can call this to fetch live web results.
    """
    try:
        results = await brave_web_search(req.query, req.num_results)
        return {"query": req.query, "results": results, "status": "OK"}
    except Exception as e:
        return {"query": req.query, "results": [], "status": f"ERROR: {e}"}


@app.post("/v1/generate_file")
def generate_file(req: GenerateFileRequest) -> Dict[str, Any]:
    """
    Use RILIE to answer the stimulus, then save that answer as a file
    (md/js/py/json/txt/docx/pdf) and return both the text and a download URL.
    """
    stimulus = req.stimulus.strip()
    if not stimulus:
        return {
            "stimulus": "",
            "ext": sanitize_ext(req.ext),
            "content": "",
            "status": "EMPTY",
            "filename": "",
            "download_url": "",
        }

    result = guvna.process(stimulus, maxpass=3)
    content = str(result.get("result", ""))
    ext = sanitize_ext(req.ext)
    filename = save_generated_file(ext, content)

    return {
        "stimulus": stimulus,
        "ext": ext,
        "content": content,
        "status": "OK",
        "filename": filename,
        "download_url": f"/download/{filename}",
    }


@app.get("/download/{filename}")
def download_file(filename: str):
    """
    Serve a previously generated file from the generated/ directory so the
    browser can download it.
    """
    path = GENERATED_DIR / filename
    if not path.exists():
        raise HTTPException(status_code=404, detail="File not found")

    return FileResponse(
        path,
        media_type="application/octet-stream",
        filename=filename,
    )


@app.post("/v1/ocr")
async def ocr_image(file: UploadFile = File(...)) -> Dict[str, Any]:
    """
    Accept an image upload and return text extracted via Google Cloud Vision OCR.
    """
    try:
        image_bytes = await file.read()
        if not image_bytes:
            return {"filename": file.filename, "text": "", "status": "EMPTY"}
        text = google_ocr(image_bytes)
        return {"filename": file.filename, "text": text, "status": "OK"}
    except Exception as e:
        return {"filename": file.filename, "text": "", "status": f"ERROR: {e}"}


# ---------------------------------------------------------------------------
# PRE-RESPONSE endpoint (skeleton matching PRE-RESPONSE.txt)
# ---------------------------------------------------------------------------


@app.post("/pre-response", response_model=PreResponseResponse)
async def pre_response(req: PreResponseRequest) -> PreResponseResponse:
    """
    Implements the PRE-RESPONSE pattern in skeleton form:
    - If question is clear and shallow: Brave-search Q, count results.
    - Else: later expand Q across the Roux grid and store in BANKS.
    For now, this only exercises Brave + basic counting, no BANKS writes.
    """
    q = req.question.strip()
    if not q:
        return PreResponseResponse(
            question=q,
            shallow=req.shallow,
            harvested=0,
            status="EMPTY",
        )

    harvested = 0
    try:
        results = await brave_web_search(q, req.numresults)
        harvested = len(results)
    except Exception as e:
        return PreResponseResponse(
            question=q,
            shallow=req.shallow,
            harvested=0,
            status=f"ERROR: {e}",
        )

    return PreResponseResponse(
        question=q,
        shallow=req.shallow,
        harvested=harvested,
        status="OK",
    )
